UMDK-LIT
	DIO29 SCL
	DIO30 SDA

UMDK-6FET
	DIO5 ch0
	DIO6 ch1
	DIO7 ch2
	DIO24 ch3
	DIO25 ch4
	DIO26 ch5

UMDK-4BTN
	DIO4 KEY_A
	DIO5 KEY_B
	DIO6 KEY_C
	DIO7 KEY_D


/*---------------------------------------------------------------------------*/
/*ПРОТОКОЛ*/ 
/*------------------------------------*/
Пакеты в сети состоят из header'а и payload'а.
ROOT обрабатывает пакеты с командами и данными только после авторизации. 
Авторизация проходит в четыри стадии.

/*---------------------------------------------------------------------------*/
/*HEADER*/
typedef struct {
	uint8_t protocol_version;	/*Текущая версия протокола*/ 
    uint8_t device_id;			/*ID устройства*/
	uint8_t data_type;			/*Тип пакета*/ 
	uint8_t rssi;				/*RSSI*/ 
	uint8_t temperature;		/*Температура*/ 
	uint8_t voltage;			/*Напряжение*/ 
} pack header_up_t;

typedef struct {		
    u8_u16_t counter;			/*Счетчик пакетов*/ 
	u8_u16_t crc;				/*CRC16*/ 
	uint8_t length;				/*Размер пакета*/
} pack header_down_t;

typedef struct {		
	uint8_t protocol_version;	/*Текущая версия протокола*/ 
    uint8_t device_id;			/*ID устройства*/
	uint8_t data_type;			/*Тип пакета*/ 
	uint8_t rssi;				/*RSSI*/ 
	uint8_t temperature;		/*Температура*/ 
	uint8_t voltage;			/*Напряжение*/ 
	u8_u16_t counter;			/*Счетчик пакетов*/ 
	u8_u16_t crc;				/*CRC16*/ 
	uint8_t length;				/*Размер пакета*/
} pack header_t; 

/*---------------------------------------------------------------------------*/
/*UNWDS-6LOWPAN_SYSTEM*/
/*Авторизация*/ 
/*------------------------------------*/
1 Шаг: JOIN_STAGE_1
Направление: DAG->ROOT

typedef struct {		
	uint8_t module_id;		/*ID устройства: module_id = UNWDS_MODULE_ID*/	
} pack join_stage_1_t;

/*------------------------------------*/
2 Шаг: JOIN_STAGE_2
Направление: ROOT->DAG

typedef struct {		
	u8_u16_t nonce;			/*Генерируем сессионный ключ: nonce = random_rand()*/	
} pack join_stage_2_t;

/*------------------------------------*/
3 Шаг: JOIN_STAGE_3
Направление: DAG->ROOT

typedef struct {			
	u8_u16_t nonce;			/*Увеличиваем nonce на единицу: nonce += 1*/	
} pack join_stage_3_t;

/*------------------------------------*/
4 Шаг: JOIN_STAGE_4
Направление: ROOT->DAG		

typedef struct {		
	uint8_t status_code;	/*status_code = true если авторизация прошла успешно, иначе status_code = false*/	
} pack join_stage_4_t;
/*------------------------------------*/

Если устройство прошло авторизацию, то ROOT включает устройство в сеть и обрабатывает входящие пакеты от устройства.

/*---------------------------------------------------------------------------*/
/*UNWDS-6LOWPAN_SYSTEM*/
/*СЛУЖЕБНЫЕ ПАКЕТЫ*/

/*------------------------------------*/
Пакет: PING
Направление: DAG->ROOT

typedef struct {		
	u8_u16_t nonce;			/*Отправляем ROOT'у nonce. Если 3 раза не ответит, то перезагружаемся и переавторизируемся*/
} pack ping_t;

/*------------------------------------*/
Пакет: PONG
Направление: ROOT->DAG	

typedef struct {		
	uint8_t status_code;	/*status_code = true если настройки шифрования совпадают*/
} pack pong_t;

/*------------------------------------*/
Пакет: ACK
Направление: DAG->ROOT

typedef struct {		
	u8_u16_t counter;		/*Номер подтвержденного пакета*/
} pack ack_t;

/*------------------------------------*/
Пакет: NACK
Направление: DAG->ROOT

typedef struct {		
	u8_u16_t counter;		/*Номер неподтвержденного пакета*/
} pack nack_t;

/*---------------------------------------------------------------------------*/
/*UNWDS-4BTN*/
/*------------------------------------*/
Пакет: BUTTON_STATUS
Направление: DAG->ROOT

typedef struct {		
	uint8_t button_status;	/*Номер нажатой кнопки. Если долгое нажатие: button_status |= (1<<7) */
} pack button_status_t;

/*---------------------------------------------------------------------------*/
/*UNWDS-6FET*/
/*------------------------------------*/
Пакет: PWM_SETTINGS
Направление: ROOT->DAG

typedef struct {
	uint32_t frequency;		/*Частота ШИМ'а от 100 Hz до 100 kHz*/
	uint8_t channel;		/*Номер канала от 0 до 5*/
	uint8_t duty;			/*Коэффицент заполнения от 0% до 100%*/
} pack pwm_settings_t;

/*------------------------------------*/
Пакет: PWM_POWER
Направление: ROOT->DAG

typedef struct {		
	uint8_t pwm_power;		/*Номер канала от 0 до 5. Для включения: номер канала |= (1<<7)*/
} pack pwm_power_t;

/*---------------------------------------------------------------------------*/
/*UNWDS-LIT*/
/*------------------------------------*/
Пакет: LIT_MEASURE
Направление: ROOT->DAG

У ЭТОГО ПАКЕТА НЕТ PAYLOAD'А

/*------------------------------------*/
Пакет: LIT_MEASURE_STATUS
Направление: DAG->ROOT

typedef struct {		
	uint32_t lit_measure_status;	/*Значение освещенности в люксах*/
} pack lit_measure_status_t;

/*---------------------------------------------------------------------------*/
/*ПРОТОКОЛ CR->ROOT*/
/*------------------------------------*/
Для того что бы отправить пакет авторизированому устройству микрокомпьютеру нужно передать по UART'у header и payload.
В заголовке указываем адрес модуля, ID модуля, команду и длину payload'а. Если payload'а нет, то payload_len = 0. После заголовка передаем payload.

typedef struct {		
	uip_ip6addr_t dest_addr; 	/*Адрес модуля*/
	uint8_t device_id; 			/*Индентификатор модуля*/
	uint8_t data_type; 			/*Команда*/
	uint8_t payload_len;		/*Размер payload'а*/
} pack uart_header_t;

/*------------------------------------*/
/**/
/*------------------------------------*/
CMD:
AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA ID CMD LEN XX XX XX XX XX XX

Адрес:
0xFD 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x02 0x12 0x4B 0x00 0x0C 0x46 0x8D 0x03 

ID:
	UNWDS-6FET: 0x0E
	UNWDS-LIT: 0x0F

CMD:
/*UNWDS-6FET*/
	PWM_SETTINGS: 0x00		/*Пакет с настройкоами ШИМ канала*/
	PWM_POWER: 0x01			/*Команда включения/выключения канала ШИМ'а*/

/*UNWDS-LIT*/
	LIT_MEASURE: 0x00		/*Команда запроса замера освещенности*/
/*------------------------------------*/
/*Примеры*/
/*------------------------------------*/
/*PWM_SETTINGS*/
/*[PWM] Channel 0 is configured: 1000 Hz, duty 50 percent, 5 pin*/
0xFD 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x02 0x12 0x4B 0x00 0x0C 0x46 0x8D 0x03 0x0E 0x00 0x06 0xE8 0x03 0x00 0x00 0x00 0x32

/*PWM_POWER*/
/*[PWM] Channel 0 is running*/
0xFD 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x02 0x12 0x4B 0x00 0x0C 0x46 0x8D 0x03 0x0E 0x01 0x01 0x80

/*LIT_MEASURE*/
/*[UMDK-LIT] Luminocity: 200 lux*/
0xFD 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x02 0x12 0x4B 0x00 0x0C 0x46 0x8D 0x03 0x0F 0x00 0x00

/*---------------------------------------------------------------------------*/
/*ПРОТОКОЛ ROOT-CR*/
/*------------------------------------*/
ROOT все приходящие пакеты выдает микрокомпьютеру по UART'у.
Посылка состоит из адресса устройства в сети и самого пакета.

/*---------------------------------------------------------------------------*/
/*РАЗБОР ПАКЕТА МИКРОКОМПЬЮТЕРОМ*/
/*------------------------------------*/

/*Отражаем структуру на массив*/ 
header_up_t *header_up_pack = (header_up_t*)&data[HEADER_OFFSET];

/*Проверяем версию протокола*/ 
if(header_up_pack->protocol_version == UDBP_PROTOCOL_VERSION)
{		
	/*Проверяем ID модуля*/ 
	/*UNWDS-6LOWPAN_SYSTEM*/
	if(header_up_pack->device_id == UNWDS_6LOWPAN_SYSTEM_MODULE_ID)
	{
		if(header_up_pack->data_type == JOIN_STAGE_1)
		{
			/*Обработчик 1 стадии авторизации*/			
			join_stage_1_handler((uip_ip6addr_t*)sender_addr, data, datalen);
			
			return;
		}
		
		else if(header_up_pack->data_type == JOIN_STAGE_3)
		{
			/*Обработчик 3 стадии авторизации*/
			join_stage_3_handler((uip_ip6addr_t*)sender_addr, data, datalen);
			
			return;
		}
		
		else if(header_up_pack->data_type == PING)
		{
			/*Ping*/
			ping_handler((uip_ip6addr_t*)sender_addr, (ping_t*)&data[PAYLOAD_OFFSET]);
			
			return;
		}
		
		else if(header_up_pack->data_type == ACK)
		{
			/*ACK*/
			ack_handler((uip_ip6addr_t*)sender_addr, (ack_t*)&data[PAYLOAD_OFFSET]);
			
			return;
		}
		
		else if(header_up_pack->data_type == NACK)
		{
			/*NACK*/
			nack_handler((uip_ip6addr_t*)sender_addr, (nack_t*)&data[PAYLOAD_OFFSET]);
			
			return;
		}
		
		else
		{	
			/*Вывод сообщения об неизвестной команде*/
			printf("[");
			uip_debug_ipaddr_print((uip_ip6addr_t*)sender_addr);
			printf("] Unknown command for system!\n");
			
			return;
		}
	}
	
	/*UMDK-4BTN*/
	if(header_up_pack->device_id == UNWDS_4BTN_MODULE_ID)
	{
		if(header_up_pack->data_type == BUTTON_STATUS)
		{
			/*Обработчик пакета с статусом нажатой кнопки*/
			button_status_handler((uip_ip6addr_t*)sender_addr, (button_status_t*)&data[PAYLOAD_OFFSET]);
			
			return;
		}
		
		else
		{	
			/*Вывод сообщения об неизвестной команде*/
			printf("[");
			uip_debug_ipaddr_print((uip_ip6addr_t*)sender_addr);
			printf("] Unknown command for UMDK-4BTN!\n");
	
			return;
		}
	}

	/*UMDK-LIT*/
	else if(header_up_pack->device_id == UNWDS_LIT_MODULE_ID)
	{
		if(header_up_pack->data_type == LIT_MEASURE_STATUS)
		{
			/*Обработчик пакета замера освещенности*/
			lit_measure_status_handler((uip_ip6addr_t*)sender_addr, (lit_measure_status_t*)&data[PAYLOAD_OFFSET]);
			
			return;
		}
		
		else
		{	
			/*Вывод сообщения об неизвестной команде*/
			printf("[");
			uip_debug_ipaddr_print((uip_ip6addr_t*)sender_addr);
			printf("] Unknown command for UMDK-LIT!\n");
	
			return;
		}
	}
	
	else
	{	
		/*Вывод сообщения о неизвестном модуле*/
		printf("[");
		uip_debug_ipaddr_print((uip_ip6addr_t*)sender_addr);
		printf("] Unknown module!\n");

		return;
	}
}

else 
{
	/*Вывод сообщения о неизвестном протоколе*/
	printf("[");
	uip_debug_ipaddr_print((uip_ip6addr_t*)sender_addr);
	printf("] Unknown protocol version!\n");
	
	return;
}
